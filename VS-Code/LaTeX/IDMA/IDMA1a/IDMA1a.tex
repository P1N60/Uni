\documentclass[a4paper,12pt]{article}
\usepackage{standalone}
\usepackage{amsmath} % Package for advanced math typesetting
\input{../../sty/setup.sty} % Assuming these files exist and are correctly referenced
\graphicspath{ {../../pictures/PoP/assignment2}} % Assuming a pictures folder has been made and is correctly referenced

% \renewcommand{\thesection}{5.\arabic{section}} % Substitue 5. for any number

% Changes sections from 1.1 to 1.a
\renewcommand{\thesubsection}{\thesection.\alph{subsection}}

\begin{document}
% \includepdf[pages=-]{../../pictures/forside}

\title{Københavns Universitet\\
Introduktion til diskret matematik og algoritmer - Problem set 1}
\input{../../sty/cover.sty} % Assuming this file contains the cover page setup
\input{../../sty/header.sty} % Assuming this file contains the header setup
\maketitle % This command will actually insert the title into the document

% Question 1
\section[Question 1]{Question 1 - In the following snippet of code A and B are arrays indexed from 1 to n that contain numbers. }

\begin{lstlisting}
for i := 1 upto n { 
    B[i] := 1 
    for j := 1 upto i {
        B[i] := B[i] * A[j] 
    }
} 
\end{lstlisting}

\subsection[]{Explain in plain language what the algorithm above does. In particular, what is the meaning of the entries B [i] after the algorithm has terminated? }

Algoritmet ændrer hvert element i array'en B til produktet af alle elementer i A op til samme nummer element (i).

\subsection[]{Provide an asymptotic analysis of the running time as a function of the array size n. (That is, state how the worst-case running time scales with n, focusing only on the highest-order term, and ignoring the constant factor in front of this term.)}

Lad os kigge på hvordan running time fordeles i vores algoritme:
\begin{lstlisting}
for i := 1 upto n {         //O(n^2)
    B[i] := 1               //O(1)
    for j := 1 upto i {     //O(n)
        B[i] := B[i] * A[j] //O(1)
    }
}
\end{lstlisting}
Vi ser, at vi har n gentagelser af for-loop'et, som indeholder n gentagelser i endnu et for-loop. Dette resulterer i en worst-case $cn^2 + cn + c \Rightarrow O(n^2)$

\subsection[]{Can you improve the code to run faster while retaining the same functionality? How
much faster can you get the algorithm to run? Analyse the time complexity of your new
algorithm. Can you prove that it is asymptotically optimal? (That is, that no algorithm
solving this problem can run faster except possibly for a constant factor in the highest-order
term or improvements in lower-order terms. )}

For at gøre vores algoritme betydligt hurtigere, bør vi se, om vi kan få en worst-case asymptotic time complexcity på n eller bedre.\\
(Bemærk at jeg bruger en anden snytax for min egen pseudokode)
\begin{lstlisting}
B[1] := A[1]               //O(1)
for i := 2 upto n          //O(n)
    B[i] := B[i-1] * A[i]  //O(1)
\end{lstlisting} 
Dette nye algortime vedholder samme funktionalitet som det tidlige, og kører i: $cn + c \Rightarrow O(n)$ asymptotic running time, hvilket er hurtigere, da dette skalerer lineært.\\
Jeg vil selv mene, at dette er "asymptotically optimal", da jeg ikke ser en anden måde, hvorpå man kan iterere gennem hvert element i en array, som er hurtigere end lineær running time.\\
Dog kan jeg ikke bevise, at dette er den hurtigste måde.

% Question 2
\section[Question 2]{Question 2 - In the following snippet of code A is an array indexed from 1 to n that contain elements
that can be compared}

\begin{lstlisting}
j := n
good := TRUE
while (j > 1 and good)
    i := j - 1
    while (i >= 1 and good)
        if (A[i] > A[j])
            good := FALSE
        i := i - 1
    j := j - 1
if (good)
    return "success"
else
    return "failure"
\end{lstlisting}
    
\subsection[]{Explain in plain language what the algorithm above does. In particular, what do we know
about the array A when "success" or "failure" is returned, respectively?}

Algoritmet retunerer "success" eller "failure", afhængigt af om alle elementers værdi i array'en A øges i tagt med elementnummeret, eller har samme værdi.
Når "success" er retuneret, ved vi, at array'en A kun indeholder elementer, der har samme eller højere værdi end elementet før for hvert element i A. Sagt med andre ord er elle elementer i A sorteret fra laveste til højeste værdi, hvis "success" er retuneret.\\
Når "failure" er retuneret, er der et eller flere elementer, hvis værdi ikke øges i tagt med elementnummeret eller ikke er den samme. Med andre ord er array'en ikke sorteret i increasing rækkefølge.
    
\subsection[]{Provide an asymptotic analysis of the running time as a function of the array size n. (That
is, state how the worst-case running time scales with n, focusing only on the highest-order
term, and ignoring the constant factor in front of this term.)}
    
\begin{lstlisting}
j := n                      //O(1)
good := TRUE                //O(1)
while (j > 1 and good)      //O(n^2)
    i := j - 1              //O(1)
    while (i >= 1 and good) //O(n)
        if (A[i] > A[j])    //O(1)
            good := FALSE   //O(1)
        i := i - 1          //O(1)
    j := j - 1              //O(1)
if (good)                   //O(1)
    return "success"        //O(1)
else                        //O(1)
    return "failure"        //O(1)
\end{lstlisting}
$cn^2 + cn + c \Rightarrow O(n^2)$

\subsection[]{Can you improve the code to run faster while retaining the same functionality? How
much faster can you get the algorithm to run? Analyse the time complexity of your new
algorithm. Can you prove that it is asymptotically optimal? (That is, that no algorithm
solving this problem can run faster except possibly for a constant factor in the highest-order
term or improvements in lower-order terms. )}

Min forbedrede version af algoritmet er som følgende:\\
(Bemærk at snytax'en for pseudokoden ikke er den samme som i opgaven)
\begin{lstlisting}
sorted := True          //O(1)
for i := 1 upto n-1     //O(n)
    if (A[i] > A[i+1])  //O(1)
        sorted := False //O(1)
if (sorted)             //O(1)
    return "success"    //O(1)
else                    //O(1)
    return "failure"    //O(1)
\end{lstlisting}
Jeg har afskaffet begge while-loops og erstattet dem med et enkelt for-loop, som tjekker om alle elementer er i øget- eller lig rækkefølge.\\
For-loopet kører til n-1, og er det højeste asymptotiske led, hvilket giver os en worst-case running time: $cn + c \Rightarrow O(n)$.

% Question 3
\section[Question 3]{Question 3 - In the following snippet of code A is an array indexed from 1 to n that contains integers,
and B is an auxiliary array, also indexed from 1 to n, that is meant to contain Boolean values.}

\begin{lstlisting}
for i := 1 upto n {
    if (A[i] < 1 or A[i] > n)
        return "failure"
}
i := 1
found := -1
while (i <= n and found < 0) {
    for j := 1 upto n {
        B[j] := false
    }
    j := 1
    while (B[j] == false) {
        B[j] := true
        j := A[j]
    }
    if (A[A[j]] == j)
        found := j
    i := i + 1
}
return found
\end{lstlisting}
    
\subsection[]{Explain in plain language what the algorithm above does. In particular, when does it
return a positive value, and, if it does, what is the meaning of this value?}
    
Algoritmet søgerer først for, at alle elementer i array'en A kun indeholder værdier der er imellem 1 og længden (antallet af elementer) af array'en. Hvis dette er tilfældet, retuneres "failure". Hvis algoritmet ikke retunerer "failure", retunerer den -1 hvis der ikke er nogle elementer, der peger på et element, som peger tilbage igen (en cyklus). Hvis sådan en cyklus bliver fundet, bliver index'et af det gældende element retuneret.
    
\subsection[]{Provide an asymptotic analysis of the running time as a function of the array size n. (That
is, state how the worst-case running time scales with n, focusing only on the highest-order
term, and ignoring the constant factor in front of this term.)}
    
\begin{lstlisting}
for i := 1 upto n {             //O(n)
    if (A[i] < 1 or A[i] > n)   //O(1)
        return "failure"        //O(1)
}
i := 1                          //O(1)
found := -1                     //O(1)
while (i <= n and found < 0) {  //O(n^2)
    for j := 1 upto n {         //O(n)
        B[j] := false           //O(1)
    }
    j := 1                      //O(1)
    while (B[j] == false) {     //O(n)
        B[j] := true            //O(1)
        j := A[j]               //O(1)
    }
    if (A[A[j]] == j)           //O(1)
        found := j              //O(1)
    i := i + 1                  //O(1)
}
return found                    //O(1)
\end{lstlisting}
Vi ser, at vi har en worst-case asymptotic running time på $cn^2 + cn + c \Rightarrow O(n^2)$, da vi har et for-loop inde i et while-loop, som begge kører n gange.

\subsection[]{Can you improve the code to run faster while retaining the same functionality? How
much faster can you get the algorithm to run? Analyse the time complexity of your new
algorithm. Can you prove that it is asymptotically optimal?}

Her er min version af algoritmet:
\begin{lstlisting}
for i := 1 upto n               //O(n)
    if (A[i] < 1 or A[i] > n)   //O(1)
        return "failure"        //O(1)
    B[i] := False               //O(1)
found := -1                     //O(1)
for j := 1 upto n               //O(n)
    if (A[A[j]] == j)           //O(1)
        found := j              //O(1)
    if (found > 0)              //O(1)
        return found            //O(1)
return found                    //O(1)
\end{lstlisting}
Dette kører med $cn + c$ asymptotic running time, hvilket svarer til $O(n)$ (linæer) tid.

% Question 4
\section[Question 4]{Question 4 - In the following snippet of code A is an array indexed from 1 to n > 2 containing integers.}

\begin{lstlisting}
search (A, lo, hi)
    if (A[lo] >= A[hi])
        return "failure"
    else if (lo + 1 == hi)
        return lo
    else 
        mid = floor ((lo + hi) / 2)
        if (A[mid] > A[lo])
            search (A, lo, mid)
        else
            search (A, mid, hi)
\end{lstlisting}

\begin{itemize}
    \item[] \textbf{The first call to the algorithm is search (A, 1, n), where n is whatever size (at least 2) the
    array has.}
\end{itemize}

\subsection[]{Explain in plain language what the algorithm above does. If the algorithm returns something other than "failure", then what is the meaning of the value returned?}
    
    
    
\subsection[]{Provide an asymptotic analysis of the running time as a function of the array size n.}
    
    

\subsection[]{Could it be the case that recursive calls of the algorithm also return "failure", or would it
be sufficient to check just once before making the first recursive call? If we get the additional
guarantee that all elements in the array are distinct, could we remove the "failure" check
completely, since we would be guaranteed to never have this answer returned anyway?
What about if we get the additional guarantee that the array is sorted in increasing order?
What if both of these extra guarantees apply?}




\end{document}